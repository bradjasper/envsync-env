"""
    Proxy Views

    These are views that interact with the vendor proxies, either through
    rate searches or order reservations.
"""
import datetime
from json import dumps, loads
import sys
import os

from django.shortcuts import get_object_or_404
from django.http import HttpResponse, HttpResponseRedirect, \
        HttpResponseServerError
from django.core.mail import mail_admins
import MySQLdb

from matrix.models import Result
from forms import SearchForm
from format import slugify
from logger import Logger
from rcn_parser.models import Reservation, Customer, Address, Rate, \
        Location as Loc, LocationTime, CreditCard
from proxy import get_proxy
from places.models import Location, Vendor
from proxy.client import Client
from travelguard.client import Client as TGClient
from proxy.forms import CheckoutForm, CancelForm
from proxy.models import Order, STATUS_CANCELLED, STATUS_ACTIVE, \
        STATUS_INACTIVE
from travelguard.models import Policy
from toolbox import convert_datetime
from templates import Template
from errors import DuplicateRes, Response, Places, ProxyError, CheckoutError, DateError
from mailman import Mailer
from mailman.utils import send_admins_error
from affiliate.models import Affiliate
from matrix.utils import clear_searches
from django.conf import settings
from creditcard.forms import CreditCardForm
from creditcard.utils import get_cc_type
from utils import get_inactive_order, get_order_keys_from_request, \
        get_rate_with_locations_from_db

template = Template()

def get_unique_id(*args):
    """Combine the arguments to generate a unique string"""

    cleaned = [unicode(arg).strip() for arg in args]

    return '-'.join(cleaned).replace(' ', '-')

def query(request):
    """Start the query from the AJAX client"""

    response = HttpResponse()
    response_msg = {}

    try:
        pickup = LocationTime(datetime=convert_datetime(
                request.REQUEST.get('pickup_datetime')))

        dropoff = LocationTime(datetime=convert_datetime(
                request.REQUEST.get('dropoff_datetime')))

        pickup.location = Loc(code=request.REQUEST.get('pickup_code'))
        dropoff.location = Loc(code=get_dropoff_code(request))


        response_msg['unique_id'] = start_query(request, pickup, dropoff)

    except Places, msg:
        response_msg["error"] = \
                "Couldn't find any matches for the location you entered"

    try:
        response.write(dumps(response_msg))
    except TypeError:
        assert False, response_msg


    return response


def get_dropoff_code(request):
    """Return the dropoff code"""
    code = request.REQUEST.get('dropoff_code')

    if not code:
        code = request.REQUEST.get('dropoff_name')

    if not code:
        code = request.REQUEST.get('pickup_code')

    if not code:
        code = request.REQUEST.get('pickup_name')

    if not code:
        raise Exception("Can't find dropoff code")

    return code

def search(request):
    """Search for rates front-end"""

    form = SearchForm()
    unique_id = request.REQUEST.get('unique_id')
    error = None

    # Exception for profiler
    if request.method == "POST" or request.REQUEST.get('pickup_code'):

        try:
            pickup_date = request.REQUEST.get('pickup_datetime_0').split('/')
            dropoff_date = request.REQUEST.get('dropoff_datetime_0').split('/')

            if len(pickup_date) != 3:
                raise DateError("Please provide a valid pickup date (mm/dd/yyyy)")

            if len(dropoff_date) != 3:
                raise DateError("Please provide a valid dropoff date (mm/dd/yyyy)")

            pickup = LocationTime(datetime=datetime.datetime(
                int(pickup_date[2]), # Year
                int(pickup_date[0]), # Month
                int(pickup_date[1]), # Day
                int(request.REQUEST.get('pickup_datetime_1_hour')),
                int(request.REQUEST.get('pickup_datetime_1_minute')),
                int(request.REQUEST.get('pickup_datetime_1_second'))))

            dropoff = LocationTime(datetime=datetime.datetime(
                int(dropoff_date[2]), # Year
                int(dropoff_date[0]), # Month
                int(dropoff_date[1]), # Day
                int(request.REQUEST.get('dropoff_datetime_1_hour')),
                int(request.REQUEST.get('dropoff_datetime_1_minute')),
                int(request.REQUEST.get('dropoff_datetime_1_second'))))

            pickup.location = Loc(code=request.REQUEST.get('pickup_code'))
            dropoff.location = Loc(code=get_dropoff_code(request))

            form = SearchForm(request.REQUEST)

            unique_id = start_query(request, pickup, dropoff)

        except (Places, DateError), msg:
            error = msg


    return template.render_to_response('search.html', {
        'search_form': form,
        'unique_id': unique_id,
        'error': error})

def start_query(request, pickup, dropoff):
    """Start the rates proxies on the backend"""

    assert pickup.location.code, 'Invalid pickup code'
    assert dropoff.location.code, 'Invalid dropoff code'

    response = HttpResponse()
    error = None
    session_id = request.COOKIES.get('sessionid')
    log = Logger('rcn.main.views', session_id)

    log.info("Starting query for %s and %s", pickup, dropoff)

    if session_id is None:
        return HttpResponseServerError("Invalid Session ID")

    pairs = Location.objects.get_matches(pickup.location.code,
            dropoff.location.code)

    if len(pairs) == 0:
        raise Places("""We were unable to find a match for the locations
                you entered""")


    log.info('Found %d location pairs - %s', len(pairs), pairs)

    unique_id = get_unique_id(session_id, pickup.location.code,
        dropoff.location.code, pickup.datetime, dropoff.datetime)

    clear_searches(unique_id)

    if not settings.LIVE:
        os.system(os.path.join(settings.ROOT_DIR, "scripts/tunnels/dev.sh"))

    Client(pairs, pickup.datetime, dropoff.datetime, unique_id)

    return unique_id


def checkout(request, reference_id):
    """Checkout view, user is completing a reservation"""

    checkout_form = CheckoutForm()
    creditcard_form = CreditCardForm()
    purchase = None

    session_id = request.COOKIES.get('sessionid')
    messages = {}

    if session_id is None:
        return HttpResponseServerError("Invalid Session ID")
        
    log = Logger('rcn.main.views', session_id)

    try:
        result = Result.objects.get(reference_id=reference_id)
    except Result.DoesNotExist:
        # If the rate has expired, give the user a more friendly message
        # than a 404
        return HttpResponseRedirect("/expired/%s.html" % reference_id)

    raw_rate = Rate.initialize(result.data)
    rate = get_rate_with_locations_from_db(result.data)
    vendor = get_object_or_404(Vendor, name=rate.vendor.name)

    if request.method == "POST":

        try:
           # Initialize these together so the user doesn't loose data
            checkout_form = CheckoutForm(request.POST)

            # Manually check if we require insurance since we don't have
            # cleaned data yet
            insurance_cc = checkout_form.data.get('insurance') == "on"
            req_cc = rate.req_cc or insurance_cc

            if req_cc:
                creditcard_form = CreditCardForm(request.POST)

            if not checkout_form.is_valid():
                raise CheckoutError("""Please fill out all required fields.
                Required fields are marked with an asterik (*).""")

            if req_cc:
                if not creditcard_form.is_valid():
                    raise CheckoutError("""This reservation requires
                        a credit card. Please fill out the credit card
                        form below.""")

            items = get_order_keys_from_request(request,
                    reference_id=reference_id)

            order = get_inactive_order(**items)

            # Only grab an existing order if its inactive. If its active
            # or cancelled we just want to ignore it
            if order and order.status != STATUS_INACTIVE:
                order = None

            res = Reservation.from_form_data(checkout_form.cleaned_data,
                    rate=raw_rate)

            if req_cc:
                res.cc = CreditCard(**creditcard_form.cleaned_data)


            # If there isn't already an order, lets make one
            if not order:

                unique_id = get_unique_id(session_id, reference_id)

                client = get_proxy(vendor, unique_id)

                # Attempt to make reservation
                reservation = client.reserve(res.rate.pickup,
                        res.rate.dropoff, res)

                if reservation.status != "active":
                    mail_admins("Reservation status isn't active",
                        """The reservation status for reservation (%s) is not 
                        active.""" % reservation, fail_silently=True)

                    raise CheckoutError("The reservation status is not active")

                # Save everything to the database
                order = checkout_form.save(commit=False)

                order.vendor = vendor
                order.pickup_location = rate.pickup.location
                order.dropoff_location = rate.dropoff.location

                order.pickup_datetime = rate.pickup.datetime
                order.dropoff_datetime = rate.dropoff.datetime

                order.reference_id = reference_id
                order.confirm_num = reservation.confirm_num
                order.session_id = session_id
                order.res_data = reservation.clean_dict()
                order.rate_data = raw_rate.clean_dict()


                try:
                    order.affiliate = Affiliate.objects.get(
                        id=request.COOKIES[settings.AFFILIATE_COOKIE_NAME])

                except Affiliate.DoesNotExist, msg:
                    mail_admins("Unknown affiliate on checkout", "%s" % msg,
                        fail_silently=True)

                except KeyError:
                    pass

                # If this order requires insurance, set this order status
                # to be inactive until we've confirmed the premium
                if checkout_form.cleaned_data['insurance']:
                    order.status = STATUS_INACTIVE

                order.save()
                checkout_form.save_m2m()


            # Attempt to make insurance purchase if needed
            if order.status == STATUS_INACTIVE:

                if checkout_form.cleaned_data['insurance']:

                    policy = Policy(reservation=res)
                    tgclient = TGClient()
                    purchase = tgclient.purchase(policy)

                    if not purchase.transaction_id:
                        raise CheckoutError("""There was an error while ordering
                            insurance: Unable to find transaction_id""")

                    order.insurance_data = purchase.clean_dict()

                # Update the status to active if there wasn't an error
                order.status = STATUS_ACTIVE
                order.save()


            try:
                mailer = Mailer()
                mailer.send_template(checkout_form.cleaned_data['email'],
                    "checkout.html", {"order": order},
                    send_from=settings.ORDERS_EMAIL)

            except Exception, msg:
                mail_admins("Mailer Failed on Checkout", """
                    The mail failed on checkout. The order was number
                    %d and the error message was '%s'""" % (
                        order.id, msg), fail_silently=True)
                
            # Redirect
            return HttpResponseRedirect(order.get_success_url())

        except (Response, CheckoutError), msg:

            # Hide the credit card number. There's no reason to ever send
            # this through e-mail.
            post = request.POST.copy()
            post['number'] = "****"
            post['ccv_number'] = "****"

            extra = """%s
DATA: %s
CHECKOUT_ERRORS: %s
CREDITCARD_ERRORS: %s""" % (msg, post, checkout_form.errors.items(),
                            creditcard_form.errors.items())

            # Make sure send_admins_error doesn't send the request in the
            # email otherwise the credit card number will be shown.
            send_admins_error(request,
                "ERROR ON CHECKOUT: There was an error while a user "
                + "was checking out.",
                traceback=sys.exc_info(), extra=extra, send_request=False)

            messages['error'] = msg.message


    return template.render_to_response('checkout.html', {
        'rate': rate,
        'form': checkout_form,
        'TRAVELGUARD_DAILY_RATE': settings.TRAVELGUARD_DAILY_RATE,
        'cc_form': creditcard_form,
        'messages': messages})



def confirm(request, order_id, confirm_num):
    """Confirm the reservation"""

    order = get_object_or_404(Order, id=order_id, confirm_num=confirm_num)
    rate = get_rate_with_locations_from_db(order.rate_data)

    return template.render_to_response('confirm.html', {
        'order': order,
        'rate': rate})


def success(request, order_id, confirm_num):
    """Called directly after reservation is ordered"""

    order = get_object_or_404(Order, id=order_id, confirm_num=confirm_num)
    rate = get_rate_with_locations_from_db(order.rate_data)

    return template.render_to_response('success.html', {
        'order': order,
        'rate': rate})


def get_reservation(order):
    """Build a reservation from an order object"""

    res = Reservation.initialize(order.res_data, rate=Rate())
    res.rate.pickup = Loc()
    res.rate.dropoff = Loc()

    # Grab locations so we have info on them from our database, not just
    # what the parser provides.
    res.rate.pickup.location = order.pickup_location
    res.rate.dropoff.location = order.dropoff_location

    return res

def cancel(request, order_id, confirm_num):
    """Cancel a reservation"""

    cancel_form = CancelForm()
    order = get_object_or_404(Order, id=order_id, confirm_num=confirm_num)
    rate = get_rate_with_locations_from_db(order.rate_data)
    error = None
    cancel_success = False

    if request.method == 'POST':

        cancel_form = CancelForm(request.POST)

        if cancel_form.is_valid():

            try:

                if not cancel_form.cleaned_data['cancel']:
                    raise ProxyError("""You must select the cancel checkbox
                        to cancel your order""")

                if order.is_cancelled:
                    raise ProxyError("""This order has already been cancelled. The
                        Confirmation number is: %s""" % order.confirm_num)

                res = get_reservation(order)

                unique_id = get_unique_id(order.session_id, order.reference_id)

                client = get_proxy(order.pickup_location.vendor, unique_id)

                cancel = client.cancel(res)

                if cancel.status != 'cancelled':
                    raise ProxyError("""Unable to cancel reservation. Status
                        is still %s""" % cancel.status)

                if not cancel.confirm_num:
                    raise ProxyError("Unable to determine confirm_num")
                    
                order.status = STATUS_CANCELLED
                order.confirm_num = cancel.confirm_num
                order.save()

                cancel_success = True


            except (ProxyError, Response), msg:
                send_admins_error(request, "Error During Cancel",
                        traceback=sys.exc_info(), extra=msg)
                error = msg.message


    return template.render_to_response('cancel.html', {
        'order': order,
        'cancel_form': cancel_form,
        'rate': rate,
        'error': error,
        'cancel_success': cancel_success,
        'TRAVELGUARD_PHONE': settings.TRAVELGUARD_PHONE})


def expired_checkout(request, reference_id, **kwargs):
    """Called when a rate isn't found (meaning its expired)"""

    send_admins_error(request, "Checkout expired for %s" % reference_id)

    kwargs['reference_id'] = reference_id

    return template.render_to_response("checkout_expired.html", kwargs)
